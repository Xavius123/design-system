import { Meta } from '@storybook/blocks';

<Meta title="Testing/Interaction Testing" />

# Interaction Testing with Storybook

Automated testing of user interactions in Storybook using `@storybook/test`.

## Overview

Interaction tests allow you to:
- Test user interactions (clicks, typing, focus)
- Verify component behavior
- Catch regressions automatically
- Run tests in Storybook UI and CI/CD

## Writing Interaction Tests

### Basic Structure

```typescript
import { expect, userEvent, within } from '@storybook/test';

export const MyStory: Story = {
  args: {
    // component props
  },
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // Find elements
    const button = canvas.getByRole('button');
    
    // Perform interactions
    await userEvent.click(button);
    
    // Make assertions
    await expect(button).toBeInTheDocument();
  },
};
```

### Available Tools

#### `within()`
Query elements within the story canvas:

```typescript
const canvas = within(canvasElement);
const button = canvas.getByRole('button');
const input = canvas.getByLabelText('Email');
const text = canvas.getByText('Hello');
```

#### `userEvent`
Simulate user interactions:

```typescript
// Click
await userEvent.click(button);

// Type text
await userEvent.type(input, 'Hello world');

// Clear input
await userEvent.clear(input);

// Tab navigation
await userEvent.tab();

// Keyboard
await userEvent.keyboard('{Enter}');
await userEvent.keyboard(' '); // Space key
```

#### `expect`
Make assertions:

```typescript
// Presence
await expect(element).toBeInTheDocument();
await expect(element).not.toBeInTheDocument();

// Content
await expect(element).toHaveTextContent('Hello');
await expect(input).toHaveValue('test');

// State
await expect(checkbox).toBeChecked();
await expect(button).toBeDisabled();
await expect(input).toHaveFocus();

// Attributes
await expect(element).toHaveAttribute('aria-label', 'Close');
```

## Component Examples

### Button Interaction Test

```typescript
export const ClickTest: Story = {
  args: {
    variant: ButtonVariant.Primary,
    children: 'Click me',
  },
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    const button = canvas.getByRole('button');
    
    // Test initial state
    await expect(button).toBeInTheDocument();
    await expect(button).toHaveTextContent('Click me');
    await expect(button).not.toBeDisabled();
    
    // Test click
    await userEvent.click(button);
  },
};
```

### Input Interaction Test

```typescript
export const TypingTest: Story = {
  args: {
    label: 'Username',
    placeholder: 'Enter username',
  },
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    const input = canvas.getByLabelText('Username');
    
    // Test typing
    await userEvent.type(input, 'johndoe');
    await expect(input).toHaveValue('johndoe');
    
    // Test clearing
    await userEvent.clear(input);
    await expect(input).toHaveValue('');
  },
};
```

### Checkbox Interaction Test

```typescript
export const CheckTest: Story = {
  args: {
    label: 'Accept terms',
  },
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    const checkbox = canvas.getByRole('checkbox');
    
    // Test initial state
    await expect(checkbox).not.toBeChecked();
    
    // Test checking
    await userEvent.click(checkbox);
    await expect(checkbox).toBeChecked();
    
    // Test keyboard
    await userEvent.keyboard(' ');
    await expect(checkbox).not.toBeChecked();
  },
};
```

## Running Tests

### In Storybook UI

1. Open Storybook: `npm run storybook`
2. Navigate to a story with `play` function
3. View test results in the "Interactions" panel
4. See step-by-step execution
5. Debug failures with detailed logs

### In CI/CD

Tests run automatically with `test-storybook`:

```bash
# Install test runner
npm install --save-dev @storybook/test-runner

# Add to package.json
"scripts": {
  "test:storybook": "test-storybook"
}

# Run tests
npm run test:storybook
```

### In GitHub Actions

```yaml
- name: Run Storybook tests
  run: |
    npm run build-storybook
    npx concurrently -k -s first -n "SB,TEST" -c "magenta,blue" \
      "npx http-server storybook-static --port 6006 --silent" \
      "npx wait-on tcp:6006 && npm run test:storybook"
```

## Best Practices

### ✅ Do

- Test user-facing behavior (not implementation details)
- Use semantic queries (`getByRole`, `getByLabelText`)
- Test one interaction per story
- Use descriptive story names
- Add `await` before all assertions
- Test accessibility (ARIA attributes, keyboard navigation)

### ❌ Don't

- Test internal state or props
- Use implementation-specific queries (class names, test IDs when possible)
- Create overly complex test scenarios
- Forget to `await` async operations
- Test styling (use visual regression instead)

## Query Priority

Use queries in this order:

1. **`getByRole`** - Most accessible
   ```typescript
   canvas.getByRole('button', { name: 'Submit' })
   ```

2. **`getByLabelText`** - Good for forms
   ```typescript
   canvas.getByLabelText('Email')
   ```

3. **`getByPlaceholderText`** - When no label
   ```typescript
   canvas.getByPlaceholderText('Enter email')
   ```

4. **`getByText`** - For static text
   ```typescript
   canvas.getByText('Welcome')
   ```

5. **`getByTestId`** - Last resort
   ```typescript
   canvas.getByTestId('custom-element')
   ```

## Debugging Tests

### Console Logs

```typescript
play: async ({ canvasElement }) => {
  const canvas = within(canvasElement);
  
  // Debug: print current DOM
  console.log(canvasElement.innerHTML);
  
  // Debug: check if element exists
  const button = canvas.queryByRole('button');
  console.log('Button found:', button);
}
```

### Step-by-Step Execution

The Interactions panel shows:
- Each step of the test
- Pass/fail status
- Timing information
- Error messages with stack traces

### Pause Execution

```typescript
play: async ({ canvasElement }) => {
  const canvas = within(canvasElement);
  
  // Pause to inspect
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  await userEvent.click(button);
}
```

## Common Patterns

### Testing Error States

```typescript
export const ErrorTest: Story = {
  args: {
    error: true,
    errorMessage: 'Invalid input',
  },
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // Verify error message
    await expect(canvas.getByText('Invalid input')).toBeInTheDocument();
    
    // Verify aria-invalid
    const input = canvas.getByRole('textbox');
    await expect(input).toHaveAttribute('aria-invalid', 'true');
  },
};
```

### Testing Focus Management

```typescript
export const FocusTest: Story = {
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    const input = canvas.getByRole('textbox');
    
    // Test focus
    await input.focus();
    await expect(input).toHaveFocus();
    
    // Test tab navigation
    await userEvent.tab();
    await expect(input).not.toHaveFocus();
  },
};
```

### Testing Disabled States

```typescript
export const DisabledTest: Story = {
  args: {
    disabled: true,
  },
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    const button = canvas.getByRole('button');
    
    // Verify disabled
    await expect(button).toBeDisabled();
    
    // Verify click doesn't work
    await userEvent.click(button);
    // Component should not respond to click
  },
};
```

## Resources

- [Storybook Interaction Testing Docs](https://storybook.js.org/docs/react/writing-tests/interaction-testing)
- [Testing Library Queries](https://testing-library.com/docs/queries/about)
- [User Event API](https://testing-library.com/docs/user-event/intro)
- [Jest-DOM Matchers](https://github.com/testing-library/jest-dom)

