import { Meta } from '@storybook/blocks';

<Meta title="React Native/Component Translation Guide" />

# Component Translation Guide

Step-by-step guide for translating web components to React Native using component metadata.

## Translation Process

### Step 1: Read the Metadata

Every component has metadata that describes how to translate it:

```typescript
import { ButtonMetadata } from '@toyota/core';

// View the metadata
console.log(ButtonMetadata);
```

### Step 2: Understand Platform Differences

#### Button Example

**Web Implementation:**

```tsx
// packages/react-ui/src/components/Button/Button.tsx
import { ButtonVariant, ComponentSize } from '@toyota/core';
import type { BaseComponentProps, InteractiveWebProps, WithChildren } from '@toyota/core';

interface ButtonProps extends BaseComponentProps, InteractiveWebProps, WithChildren {
  variant?: ButtonVariant;
  type?: 'button' | 'submit' | 'reset';
}

const Button: React.FC<ButtonProps> = ({
  variant = ButtonVariant.Primary,
  size = ComponentSize.Medium,
  disabled = false,
  onClick,
  children,
}) => {
  return (
    <button
      className={styles.button}
      onClick={onClick}
      disabled={disabled}
    >
      {children}
    </button>
  );
};
```

**React Native Translation:**

```tsx
// packages/react-native-ui/src/components/Button.tsx
import { Pressable, Text, StyleSheet } from 'react-native';
import { ButtonVariant, ComponentSize } from '@toyota/core';
import type { BaseComponentProps, InteractiveNativeProps, WithChildren } from '@toyota/core';
import { lightTokens } from '@toyota/design-tokens/js/light';

interface ButtonProps extends BaseComponentProps, InteractiveNativeProps, WithChildren {
  variant?: ButtonVariant;
}

const Button: React.FC<ButtonProps> = ({
  variant = ButtonVariant.Primary,
  size = ComponentSize.Medium,
  disabled = false,
  onPress,
  children,
}) => {
  return (
    <Pressable
      onPress={onPress}
      disabled={disabled}
      style={[
        styles.button,
        styles[variant],
        styles[size],
        disabled && styles.disabled,
      ]}
    >
      <Text style={styles.text}>{children}</Text>
    </Pressable>
  );
};

const styles = StyleSheet.create({
  button: {
    borderRadius: parseInt(lightTokens.borderRadius.md),
    alignItems: 'center',
    justifyContent: 'center',
  },
  primary: {
    backgroundColor: lightTokens.color.primary,
  },
  medium: {
    paddingVertical: parseInt(lightTokens.spacing.md),
    paddingHorizontal: parseInt(lightTokens.spacing.lg),
  },
  disabled: {
    opacity: 0.5,
  },
  text: {
    color: lightTokens.color.text.inverse,
    fontSize: parseInt(lightTokens.typography.fontSize.body),
    fontWeight: lightTokens.typography.fontWeight.semibold,
  },
});
```

### Step 3: Follow Conversion Notes

The metadata includes `conversionNotes` with step-by-step instructions:

```typescript
ButtonMetadata.conversionNotes
// [
//   "Replace onClick with onPress",
//   "Replace button element with Pressable",
//   "Replace CSS classes with StyleSheet",
//   "Wrap children in Text component",
//   ...
// ]
```

### Step 4: Map States

Use `stateMapping` to handle different states:

```typescript
ButtonMetadata.stateMapping.hover
// {
//   web: ':hover CSS pseudo-class',
//   native: 'onPressIn/onPressOut callbacks'
// }
```

**Web hover:**

```css
.button:hover {
  background-color: var(--color-primary-hover);
}
```

**React Native hover:**

```tsx
const [isHovered, setIsHovered] = useState(false);

<Pressable
  onPressIn={() => setIsHovered(true)}
  onPressOut={() => setIsHovered(false)}
  style={[
    styles.button,
    isHovered && styles.buttonHovered,
  ]}
>
```

## Complete Input Translation Example

### Web Input

```tsx
// Web
import { InputType, ComponentSize } from '@toyota/core';
import type { BaseComponentProps, FormFieldProps } from '@toyota/core';

interface InputProps extends BaseComponentProps, FormFieldProps {
  type?: InputType;
  value?: string;
  onChange?: (e: React.ChangeEvent<HTMLInputElement>) => void;
}

const Input: React.FC<InputProps> = ({
  type = InputType.Text,
  label,
  value,
  onChange,
  error,
  errorMessage,
}) => (
  <div>
    {label && <label>{label}</label>}
    <input
      type={type}
      value={value}
      onChange={onChange}
      className={error ? 'error' : ''}
    />
    {error && <span>{errorMessage}</span>}
  </div>
);
```

### React Native Input

```tsx
// React Native
import { View, Text, TextInput, StyleSheet } from 'react-native';
import { InputType, ComponentSize } from '@toyota/core';
import type { BaseComponentProps, FormFieldProps } from '@toyota/core';
import { lightTokens } from '@toyota/design-tokens/js/light';

interface InputProps extends BaseComponentProps, FormFieldProps {
  type?: InputType;
  value?: string;
  onChangeText?: (text: string) => void;
}

// Map InputType to React Native keyboardType
const keyboardTypeMap: Record<InputType, any> = {
  [InputType.Text]: 'default',
  [InputType.Email]: 'email-address',
  [InputType.Password]: 'default',
  [InputType.Number]: 'numeric',
  [InputType.Tel]: 'phone-pad',
  [InputType.Url]: 'url',
  [InputType.Search]: 'default',
};

const Input: React.FC<InputProps> = ({
  type = InputType.Text,
  label,
  value,
  onChangeText,
  error,
  errorMessage,
}) => (
  <View style={styles.wrapper}>
    {label && <Text style={styles.label}>{label}</Text>}
    <TextInput
      value={value}
      onChangeText={onChangeText}
      keyboardType={keyboardTypeMap[type]}
      secureTextEntry={type === InputType.Password}
      style={[
        styles.input,
        error && styles.inputError,
      ]}
    />
    {error && errorMessage && (
      <Text style={styles.error}>{errorMessage}</Text>
    )}
  </View>
);

const styles = StyleSheet.create({
  wrapper: {
    marginBottom: parseInt(lightTokens.spacing.md),
  },
  label: {
    fontSize: parseInt(lightTokens.typography.fontSize.sm),
    color: lightTokens.color.text.secondary,
    marginBottom: parseInt(lightTokens.spacing.xs),
  },
  input: {
    borderWidth: 1,
    borderColor: lightTokens.color.border,
    borderRadius: parseInt(lightTokens.borderRadius.md),
    padding: parseInt(lightTokens.spacing.md),
    fontSize: parseInt(lightTokens.typography.fontSize.body),
    color: lightTokens.color.text.primary,
  },
  inputError: {
    borderColor: lightTokens.color.error,
  },
  error: {
    color: lightTokens.color.error,
    fontSize: parseInt(lightTokens.typography.fontSize.sm),
    marginTop: parseInt(lightTokens.spacing.xs),
  },
});
```

## Using Metadata for AI Translation

### AI Prompt Template

```
Using the component metadata from @toyota/core, translate the [ComponentName]
from web to React Native.

Web implementation: [paste web component code]

Component metadata: [paste metadata]

Requirements:
1. Use the same enums and types from @toyota/core
2. Follow the conversionNotes in the metadata
3. Use design tokens from @toyota/design-tokens/js
4. Map states according to stateMapping
5. Keep the same prop API where possible (onClick → onPress)
```

### Example AI Session

```typescript
// 1. Import metadata
import { CheckboxMetadata } from '@toyota/core';

// 2. Show AI the metadata
console.log(CheckboxMetadata);

// 3. Show AI the web implementation
import { Checkbox as WebCheckbox } from '@toyota/react-ui';

// 4. Ask AI to translate
"Create a React Native Checkbox component that matches the web implementation.
Use CheckboxMetadata.conversionNotes to guide the translation."
```

## State Management Patterns

### Focus State

**Web:**

```css
.input:focus {
  border-color: var(--color-primary);
  box-shadow: 0 0 0 3px rgba(235, 10, 30, 0.1);
}
```

**React Native:**

```tsx
const [isFocused, setIsFocused] = useState(false);

<TextInput
  onFocus={() => setIsFocused(true)}
  onBlur={() => setIsFocused(false)}
  style={[
    styles.input,
    isFocused && styles.inputFocused,
  ]}
/>

const styles = StyleSheet.create({
  inputFocused: {
    borderColor: lightTokens.color.primary,
    shadowColor: lightTokens.color.primary,
    shadowOpacity: 0.1,
    shadowRadius: 3,
  },
});
```

### Hover State (Mobile)

React Native doesn't have true hover, but you can simulate with press:

```tsx
const [isPressed, setIsPressed] = useState(false);

<Pressable
  onPressIn={() => setIsPressed(true)}
  onPressOut={() => setIsPressed(false)}
  style={[
    styles.button,
    isPressed && styles.buttonPressed,
  ]}
>
```

## Common Patterns

### Conditional Styling

**Web:**

```tsx
className={`button ${variant} ${size} ${disabled ? 'disabled' : ''}`}
```

**React Native:**

```tsx
style={[
  styles.button,
  styles[variant],
  styles[size],
  disabled && styles.disabled,
]}
```

### Tokens Usage

**Web (CSS variables):**

```css
.button {
  padding: var(--token-light-spacing-md);
  background: var(--color-light-primary);
}
```

**React Native (JS imports):**

```tsx
const styles = StyleSheet.create({
  button: {
    padding: parseInt(lightTokens.spacing.md),
    backgroundColor: lightTokens.color.primary,
  },
});
```

## Checklist

Before submitting your React Native component:

- [ ] Uses shared enums from `@toyota/core`
- [ ] Uses shared types from `@toyota/core`
- [ ] Imports tokens from `@toyota/design-tokens/js`
- [ ] Follows conversion notes from metadata
- [ ] Maps states correctly (hover, focus, active, disabled)
- [ ] Keeps same prop names (except platform-specific like onClick → onPress)
- [ ] Has TypeScript types
- [ ] Includes proper accessibility (testID, accessibilityLabel)
- [ ] Handles dark mode
- [ ] Has tests

## Resources

- [Component Metadata Files](https://github.com/toyota/design-system/tree/main/packages/core/src/metadata)
- [Design Tokens](https://github.com/toyota/design-system/tree/main/packages/design-tokens)
- [Type Definitions](https://github.com/toyota/design-system/tree/main/packages/core/src/types)

